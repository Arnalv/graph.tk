


var shaders =  {"curve.fragment":"varying vec2  MCposition;\n\nfloat f(float x){\n\treturn sqrt(1.0-x*x);\n}\nuniform float thickness;\n\nfloat normalised(float x){\n\treturn (x);\n}\nfloat unnorm(float x){\n\treturn f(x)/normalised(x);\n}\n\nvoid main() {\n\tgl_FragColor=vec4(0,0,0,0.4);\n\tfloat x = MCposition.x;\n\tfloat lower = normalised(x)* unnorm(x);\n\tif(MCposition.y > lower){\n\t\tgl_FragColor=vec4(1,0,0,0.2);\n\t\tfloat dy=0.1;\n\t\tfloat upper = unnorm(x)*(normalised(x)+ thickness*(x)*((x)));\n\t\tif(MCposition.y<upper){\n\t\t\tgl_FragColor=vec4(1,0,0,1.0);\n\t\t}\n\n\t\t\n\t}\n\n}\n","curve.vertex":"\nvarying vec2  MCposition;\n\nvoid main()\n{\n\n\tvec3 ecPosition = vec3(gl_ModelViewMatrix * gl_Vertex);\n\tvec3 tnorm      = normalize(gl_NormalMatrix * gl_Normal);\n\n\tMCposition  = gl_Vertex.xy;\n\tgl_Position = gl_ProjectionMatrix*gl_ModelViewMatrix * gl_Vertex;\n}\n","g-surface.fragment":"#ifdef GL_ES\nprecision highp float;\n#endif\n/*\nuniform vec4 uColor;\nvoid main(void) {\n\tgl_FragColor = uColor;\n}\n*/\n\nvarying vec2  MCposition;\n\nuniform vec4 uColor;\nvarying vec3 vLightWeighting;\n\nvoid main(void) {\n\tvec2 pos = mod(1.0*MCposition,vec2(1,1));\n\tif ((pos.x > 0.50)&&(pos.y > 0.5) || (pos.x < 0.5)&&(pos.y < 0.5)){\n\t\tgl_FragColor = vec4(uColor.rgb * vLightWeighting, uColor.a);\n\t}else{\n\t\tvec3 othercolor = vec3(1,1,1)-uColor.rgb;\n\t\tothercolor=othercolor*0.2+uColor.rgb*0.8;\n\t\tgl_FragColor = vec4(othercolor.rgb * vLightWeighting, uColor.a);\n\t}\n}\n","g-surface.vertex":"\n#ifdef GL_ES\nprecision highp float;\n#endif\n/*\nattribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\n\nvoid main(void) {\n\tvec3 donothing = aVertexNormal;\n    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n}\n*/\n\nattribute vec3 aVertexPosition;\nattribute vec3 aVertexNormal;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat3 uNMatrix;\n\n\nvarying vec3 vLightWeighting;\nvarying vec2  MCposition;\n\nconst float SpecularContribution = 0.5;\nconst float DiffuseContribution  = 1.0 - SpecularContribution;\nconst vec3 uAmbientColor = 0.0*vec3(1.0,1.0,1.0);\n\n\nvoid main(void){\n\tvec3 uPointLightingColor = vec3(1.0,1.0,1.0);\n\tvec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);\n\tgl_Position = uPMatrix * mvPosition;\n\tvec4 uPointLightingLocation = uMVMatrix * vec4(0.0,0.0,5.0, 1.0);\n\tvec3 lightDirection = normalize(vec3(uPointLightingLocation - mvPosition));\n\t\n\tvec3 transformedNormal = uNMatrix * normalize(aVertexNormal);\n\tfloat diffuse = max((dot(transformedNormal, lightDirection)), 0.0);\n\tfloat spec = 0.0;\n\tvec3 reflectVec = reflect(-lightDirection, transformedNormal);\n\t\n\tvec3 viewVec = normalize(-vec3(mvPosition));\n\tif (diffuse > 0.0) {\n\t\tspec = max(dot(reflectVec, viewVec), 0.0);\n\t\tspec = pow(spec, 32.0);\n\t}\n\tfloat directionalLightWeighting = DiffuseContribution * diffuse + SpecularContribution * spec;\n\t\t\n\tvLightWeighting = uAmbientColor + uPointLightingColor * directionalLightWeighting;\n\tMCposition  = aVertexPosition.xy;\n}","shader-fs.fragment":"#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec4 uColor;\nvoid main(void) {\n\tgl_FragColor = uColor;\n}\n","shader-vs.vertex":"attribute vec3 aVertexPosition;\n\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\n\nvoid main(void) {\n    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n}\n"} ;


