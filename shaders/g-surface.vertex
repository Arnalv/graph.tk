
#ifdef GL_ES
precision highp float;
#endif
/*
attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

void main(void) {
	vec3 donothing = aVertexNormal;
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
}
*/

attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform mat3 uNMatrix;


varying vec3 vLightWeighting;
varying vec2  MCposition;

const float SpecularContribution = 0.5;
const float DiffuseContribution  = 1.0 - SpecularContribution;
const vec3 uAmbientColor = 0.0*vec3(1.0,1.0,1.0);


void main(void){
	vec3 uPointLightingColor = vec3(1.0,1.0,1.0);
	vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
	gl_Position = uPMatrix * mvPosition;
	vec4 uPointLightingLocation = uMVMatrix * vec4(0.0,0.0,5.0, 1.0);
	vec3 lightDirection = normalize(vec3(uPointLightingLocation - mvPosition));
	
	vec3 transformedNormal = uNMatrix * normalize(aVertexNormal);
	float diffuse = max((dot(transformedNormal, lightDirection)), 0.0);
	float spec = 0.0;
	vec3 reflectVec = reflect(-lightDirection, transformedNormal);
	
	vec3 viewVec = normalize(-vec3(mvPosition));
	if (diffuse > 0.0) {
		spec = max(dot(reflectVec, viewVec), 0.0);
		spec = pow(spec, 32.0);
	}
	float directionalLightWeighting = DiffuseContribution * diffuse + SpecularContribution * spec;
		
	vLightWeighting = uAmbientColor + uPointLightingColor * directionalLightWeighting;
	MCposition  = aVertexPosition.xy;
}